// Copyright 2017-present Andrea Funt√≤. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package request

import (
	"io"
	"net/http"
	"net/url"
	"strings"
)

// Factory is the HTTP request factory; it can be used to create child request
// factories, with specialised BaseURLs or other parameters; when a sub-factory
// is generated, it will share the Method and BaseURL by value and all other
// firlds by pointer, so any change in sub-factories will affect the parent too.
type Factory struct {
	// // client is the HTTP client that will make the requests.
	// client *http.Client

	// userAgent is the value for the UserAgent header.
	userAgent string

	// method is the HTTP method to be used for requests generated by this
	// factory.
	method string

	// url is the base URL for generating HTTP requests.
	url string

	// headers is a set of value providers for HTTP request headers; each will
	// be asked and the set of headers will be merged before creating the request.
	headers []ValueProvider

	// parameters is a set of value providers for HTTP query parameters; each will
	// be asked and the set of values will be merged before creating the request.
	parameters []ValueProvider

	// entity is the entity provider; it will be used to generate the request
	// entity as an io.Reader. Moreover, it will be queried to set the request
	// content type.
	entity *EntityProvider
}

// New returns a request factory.
func New(method, url string) *Factory {
	return &Factory{
		method:     method,
		url:        url,
		headers:    []ValueProvider{},
		parameters: []ValueProvider{},
	}
}

// New clones the current factory and can optionally specify the request method
// and/or the request URL.
func (f *Factory) New(method, url string) *Factory {
	clone := &Factory{
		method:     f.method,
		userAgent:  f.userAgent,
		url:        f.url,
		headers:    f.headers,
		parameters: f.parameters,
		entity:     f.entity,
	}
	if method != "" {
		clone.method = strings.ToUpper(method)
	}
	if url != "" {
		clone.url = url
	}
	return clone
}

// Base sets the base URL. If you intend to extend the url with Path, the URL
// should be specified with a trailing slash.
func (f *Factory) Base(url string) *Factory {
	f.url = url
	return f
}

// Path overrides the factory URL; absolute and relative URLs can be used.
// TODO: improve documentation showing relative paths
func (f *Factory) Path(path string) *Factory {
	baseURL, baseErr := url.Parse(f.url)
	pathURL, pathErr := url.Parse(path)
	if baseErr == nil && pathErr == nil {
		f.url = baseURL.ResolveReference(pathURL).String()
		return f
	}
	return f
}

// Method sets the default HTTP method for factoory-generated requests.
func (f *Factory) Method(method string) *Factory {
	if method != "" {
		f.method = strings.ToUpper(strings.TrimSpace(method))
	}
	return f
}

// UserAgent sets the user agent information in the request factory.
func (f *Factory) UserAgent(userAgent string) *Factory {
	f.userAgent = userAgent
	return f
}

// Get sets the factory method to "GET" and updates the internal URL.
func (f *Factory) Get(pathURL string) *Factory {
	return f.Path(pathURL).Method("GET")
}

// Post sets the factory method to "POST" and updates the internal URL.
func (f *Factory) Post(pathURL string) *Factory {
	return f.Path(pathURL).Method("POST")
}

// Put sets the factory method to "PUT" and updates the internal URL.
func (f *Factory) Put(pathURL string) *Factory {
	return f.Path(pathURL).Method("PUT")
}

// Patch sets the factory method to "PATCH" and updates the internal URL.
func (f *Factory) Patch(pathURL string) *Factory {
	return f.Path(pathURL).Method("PATCH")
}

// Delete sets the factory method to "DELETE" and updates the internal URL.
func (f *Factory) Delete(pathURL string) *Factory {
	return f.Path(pathURL).Method("DELETE")
}

// Head sets the factory method to "HEAD" and updates the internal URL.
func (f *Factory) Head(pathURL string) *Factory {
	return f.Path(pathURL).Method("HEAD")
}

// Trace sets the factory method to "TRACE" and updates the internal URL.
func (f *Factory) Trace(pathURL string) *Factory {
	return f.Path(pathURL).Method("TRACE")
}

// Options sets the factory method to "OPTIONS" and updates the internal URL.
func (f *Factory) Options(pathURL string) *Factory {
	return f.Path(pathURL).Method("OPTIONS")
}

// Connect sets the factory method to "CONNECT" and updates the internal URL.
func (f *Factory) Connect(pathURL string) *Factory {
	return f.Path(pathURL).Method("CONNECT")
}

// QueryParameters add the given providers to the current set query parameter
// values providers.
func (f *Factory) QueryParameters(providers ...ValueProvider) *Factory {
	f.parameters = append(f.parameters, providers...)
	return f
}

// Headers add the given providers to the current set of header values providers.
func (f *Factory) Headers(providers ...ValueProvider) *Factory {
	f.headers = append(f.headers, providers...)
	return f
}

// Make creates a new http.Request from the information available in the Factory.
func (f *Factory) Make() (*http.Request, error) {

	// parse URL to validate
	url, err := url.Parse(f.url)
	if err != nil {
		return nil, err
	}

	// augment URL with additional query parameters
	url, err = addQueryParameters(url, f.parameters...)
	if err != nil {
		return nil, err
	}

	extraHeaders := MapProvider{values: map[string][]interface{}{}}
	if f.userAgent != "" {
		extraHeaders.Set("User-Agent", f.userAgent)
	}

	// a request may, or may not have an entity in the body (e.g. GET).
	var reader io.Reader
	if f.entity != nil {
		entity := (*f.entity).Provide()
		if entity != nil {
			reader = entity.Reader
			extraHeaders.Set("Content-Type", entity.ContentType)
		}
	}

	request, err := http.NewRequest(f.method, url.String(), reader)
	if err != nil {
		return nil, err
	}

	request = addHeaders(request, append([]ValueProvider{extraHeaders}, f.headers...)...)
	return request, nil
}

func addQueryParameters(requestURL *url.URL, providers ...ValueProvider) (*url.URL, error) {
	values, err := url.ParseQuery(requestURL.RawQuery)
	if err != nil {
		return nil, err
	}
	// encodes query structs into a url.Values map and merges maps
	for _, provider := range providers {
		parameters := provider.Provide()
		for key, list := range parameters {
			for _, value := range list {
				values.Add(key, value)
			}
		}
	}

	// url.Values formats to a sorted "url encoded" string, e.g. "key=val&foo=bar"
	requestURL.RawQuery = values.Encode()
	return requestURL, nil
}

func addHeaders(request *http.Request, providers ...ValueProvider) *http.Request {
	headers := http.Header{}
	for _, provider := range providers {
		for key, values := range provider.Provide() {
			for _, value := range values {
				headers.Add(key, value)
			}
		}
	}
	request.Header = headers
	return request
}
