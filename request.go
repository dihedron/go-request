// Copyright 2017-present Andrea FuntÃ². All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package request

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"regexp"
	"strings"

	"github.com/dihedron/go-log"
	"github.com/fatih/structs"
)

type operation int8

const (
	add operation = iota
	set
	del
	rem
)

// Builder is the HTTP request builder; it can be used to create child request
// factories, with specialised BaseURLs or other parameters; when a sub-builder
// is generated, it will share the Method and BaseURL by value and all other
// firlds by pointer, so any change in sub-factories will affect the parent too.
type Builder struct {

	// method is the HTTP method to be used for requests generated by this
	// builder.
	method string

	// url is the base URL for generating HTTP requests.
	url string

	// op is used internally to provide a flowing API to header and query parameters
	// maipulation methods.
	op operation

	// headers is a set of header values for HTTP request headers; special headers
	// such as "User-Agent" and "Content-Type" are stored here.
	headers http.Header

	// query is a set of values set in the URL as query parameters.
	parameters url.Values

	// variables is the set of values that will be used to replace placeholder in
	// the resource path, e.g. variable "id" in the following URL will be replaced
	// using a value from the map: http://www.example.com/path/resource/{id};
	// variables are populated in a way similar to that of headers and parameters.
	variables map[string]string

	// entity is the entity provider; it will be used to generate the request
	// entity as an io.Reader. Moreover, it will be queried to set the request
	// content type.
	body io.Reader
}

// New returns a new request builder; the URL can be omitted and specified
// later via Base() or Path().
func New(url string) *Builder {
	return &Builder{
		method:     http.MethodGet,
		url:        url,
		headers:    map[string][]string{},
		parameters: map[string][]string{},
		variables:  map[string]string{},
	}
}

// New clones the current builder and can optionally specify the request method
// and/or the request URL.
func (f *Builder) New(method, url string) *Builder {
	clone := &Builder{
		method:     f.method,
		url:        f.url,
		headers:    map[string][]string{},
		parameters: map[string][]string{},
		variables:  map[string]string{},
		body:       f.body,
	}
	if method != "" {
		clone.method = strings.ToUpper(method)
	}
	if url != "" {
		clone.Path(url)
	}
	for key, values := range f.headers {
		if _, ok := clone.headers[key]; !ok {
			clone.headers[key] = []string{}
		}
		clone.headers[key] = append(clone.headers[key], values...)
	}
	for key, values := range f.parameters {
		if _, ok := clone.parameters[key]; !ok {
			clone.parameters[key] = []string{}
		}
		clone.parameters[key] = append(clone.parameters[key], values...)
	}
	for key, value := range f.variables {
		clone.variables[key] = value
	}

	return clone
}

// Base sets the base URL. If you intend to extend the url with Path, the URL
// should be specified with a trailing slash.
func (f *Builder) Base(url string) *Builder {
	f.url = url
	return f
}

// Path overrides the builder URL; absolute and relative URLs can be used.
// TODO: improve documentation showing relative paths
func (f *Builder) Path(path string) *Builder {
	baseURL, baseErr := url.Parse(f.url)
	pathURL, pathErr := url.Parse(path)
	if baseErr == nil && pathErr == nil {
		f.url = baseURL.ResolveReference(pathURL).String()
	}
	return f
}

// Method sets the default HTTP method for factoory-generated requests.
func (f *Builder) Method(method string) *Builder {
	if method != "" {
		f.method = strings.ToUpper(strings.TrimSpace(method))
	}
	return f
}

// UserAgent sets the user agent information in the request builder; the previous
// value is discarded.
func (f *Builder) UserAgent(userAgent string) *Builder {
	return f.Set().Header("User-Agent", userAgent)
}

// ContentType sets the content type information in the request builder; the
// previous value is discarded.
func (f *Builder) ContentType(contentType string) *Builder {
	return f.Set().Header("Content-Type", contentType)
}

// Add is used to provide a fluent API by which it is possible to add query
// parameters and headers without having many different methods or intermediate
// objects; this method relies on an internal Builder field (named op), which
// will be set to the "add" value and will instruct the following QueryParameter()
// and Header() methods to add the passed values to the current set for the given
// key.
func (f *Builder) Add() *Builder {
	f.op = add
	return f
}

// Set is used to provide a fluent API by which it is possible to replace query
// parameters and headers without having many different methods or intermediate
// objects; this method relies on an internal Builder field (named op), which
// will be set to the "set" value and will instruct the following QueryParameter()
// and Header() methods to replace the current set of values for the given key
// with the passed values.
func (f *Builder) Set() *Builder {
	f.op = set
	return f
}

// Del is used to provide a fluent API by which it is possible to replace query
// parameters and headers without having many different methods or intermediate
// objects; this method relies on an internal Builder field (named op), which
// will be set to the "set" value and will instruct the following QueryParameter()
// and Header() methods to replace the current set of values for the given key
// with the passed values.
func (f *Builder) Del() *Builder {
	f.op = del
	return f
}

// Remove is used to provide a fluent API by which it is possible to remove the
// values of query parameters and headers whose keys match a regular exception.
func (f *Builder) Remove() *Builder {
	f.op = rem
	return f
}

// QueryParameter adds, sets or removes the given set of values to the URL's query
// parameters; if the query parameter is being removed, there is no need to specify
// any value; if the query parameter is being reset, the key is regarded as a
// regular expression.
func (f *Builder) QueryParameter(key string, values ...string) *Builder {
	if f.op == add {
		for _, value := range values {
			f.parameters.Add(key, value)
		}
	} else if f.op == set {
		f.parameters.Del(key)
		for _, value := range values {
			f.parameters.Add(key, value)
		}
	} else if f.op == del {
		f.parameters.Del(key)
	} else if f.op == rem {
		re := regexp.MustCompile(key)
		for key := range f.parameters {
			if re.MatchString(key) {
				defer f.parameters.Del(key)
			}
		}
	}
	return f
}

// QueryParametersFrom adds, sets or removes values extracted from a struct (and
// tagged with "parameter") or from a map[string][]string to the URL's query
// parameters; if the query parameters are being removed, there is no need to
// specify any value in the input struct/map; if the query parameters are being
// reset, the keys are regarded as regular expressions.
func (f *Builder) QueryParametersFrom(source interface{}) *Builder {
	for key, values := range getValuesFrom("parameter", source) {
		f.QueryParameter(key, values...)
	}
	return f
}

// Variable adds, sets or removes the given value to the URL's variables; if the
// variable is being removed, there is no need to specify the value; both setting
// and adding a value for a given variable effectively replace its value.
func (f *Builder) Variable(key string, value interface{}) *Builder {
	if f.op == add || f.op == set {
		f.variables[key] = fmt.Sprintf("%v", value)
	} else if f.op == del {
		delete(f.variables, key)
	} else if f.op == rem {
		re := regexp.MustCompile(key)
		for key := range f.variables {
			if re.MatchString(key) {
				defer delete(f.variables, key)
			}
		}
	}
	return f
}

// VariablesFrom adds/sets or removes values extracted from a struct (and
// tagged with "variable") or from a map[string]string to the URL's variables; if
// the variables are being removed, there is no need to specify any value in the
// input struct/map; if the variables are being reset, the keys are regarded as
// regular expressions.
func (f *Builder) VariablesFrom(source interface{}) *Builder {
	for key, values := range getValuesFrom("variable", source) {
		if len(values) > 0 {
			// the last value wins
			f.Variable(key, values[len(values)-1])
		}
	}
	return f
}

// Header adds, sets or removes the given set of values to the URL's headers; if
// the header is being removed, there is no need to specify any value; if the
// header is being reset, the key is regarded as a regular expression.
func (f *Builder) Header(key string, values ...string) *Builder {
	if f.op == add {
		for _, value := range values {
			f.headers.Add(key, value)
		}
	} else if f.op == set {
		f.headers.Del(key)
		for _, value := range values {
			f.headers.Add(key, value)
		}
	} else if f.op == del {
		f.headers.Del(key)
	} else if f.op == rem {
		re := regexp.MustCompile(key)
		for key := range f.headers {
			if re.MatchString(key) {
				defer f.headers.Del(key)
			}
		}
	}
	return f
}

// HeadersFrom adds, sets or removes values extracted from a struct (and tagged
// with "header") or from a map[string][]string to the URL's headers; if the
// headers are being removed, there is no need to  specify any value in the input
// struct/map; if the headers are being reset, the keys are regarded as regular
// expressions.
func (f *Builder) HeadersFrom(source interface{}) *Builder {
	for key, values := range getValuesFrom("header", source) {
		f.Header(key, values...)
	}
	return f
}

// WithEntity sets the io.Reader from which the request body (payload) will be
// read; if nil is passed, the request will have no payload; the Content-Type
// MUST be provoded separately.
func (f *Builder) WithEntity(entity io.Reader) *Builder {
	f.body = entity
	return f
}

// WithJSONEntity sets an io.Reader that returns a JSON fragment as per the
// input struct; if no Content-Type has been set already, the method will
// automatically set it to "application/json".
func (f *Builder) WithJSONEntity(entity interface{}) *Builder {

	switch reflect.ValueOf(entity).Kind() {
	case reflect.Struct:
		// do nothing, entity is already a struct, thus it's ok
	case reflect.Ptr:
		// override entity by the value it points to if it's a struct
		if reflect.ValueOf(entity).Elem().Kind() == reflect.Struct {
			entity = reflect.ValueOf(entity).Elem().Interface()
		} else {
			panic("only structs can be passed as source for JSON entities")
		}
	default:
		panic("only structs can be passed as source for JSON entities")
	}

	data, err := json.Marshal(entity)
	if err != nil {
		return nil
	}

	if f.headers.Get("Content-Type") == "" {
		f.ContentType("application/json")
	}

	f.body = bytes.NewReader(data)
	return f
}

// WithXMLEntity sets an io.Reader that returns an XML fragment as per the
// input struct; if no Content-Type has been set already, the method will
// automatically set it to "application/xml".
func (f *Builder) WithXMLEntity(entity interface{}) *Builder {

	switch reflect.ValueOf(entity).Kind() {
	case reflect.Struct:
		// do nothing, entity is already a struct, thus it's ok
	case reflect.Ptr:
		// override entity by the value it points to if it's a struct
		if reflect.ValueOf(entity).Elem().Kind() == reflect.Struct {
			entity = reflect.ValueOf(entity).Elem().Interface()
		} else {
			panic("only structs can be passed as source for XML entities")
		}
	default:
		panic("only structs can be passed as source for XML entities")
	}

	data, err := xml.Marshal(entity)
	if err != nil {
		return nil
	}

	if f.headers.Get("Content-Type") == "" {
		f.ContentType("text/xml")
	}

	f.body = bytes.NewReader(data)
	return f
}

// Get sets the builder method to "GET" and returns an http.Request.
func (f *Builder) Get() *Builder {
	return f.Method(http.MethodGet)
}

// Post sets the builder method to "POST" and returns an http.Request.
func (f *Builder) Post() *Builder {
	return f.Method(http.MethodPost)
}

// Put sets the builder method to "PUT" and returns an http.Request.
func (f *Builder) Put() *Builder {
	return f.Method(http.MethodPut)
}

// Patch sets the builder method to "PATCH" and returns an http.Request.
func (f *Builder) Patch() *Builder {
	return f.Method(http.MethodPatch)
}

// Delete sets the builder method to "DELETE" and returns an http.Request.
func (f *Builder) Delete() *Builder {
	return f.Method(http.MethodDelete)
}

// Head sets the builder method to "HEAD" and returns an http.Request.
func (f *Builder) Head() *Builder {
	return f.Method(http.MethodHead)
}

// Trace sets the builder method to "TRACE" and returns an http.Request.
func (f *Builder) Trace() *Builder {
	return f.Method(http.MethodTrace)
}

// Options sets the builder method to "OPTIONS" and returns an http.Request.
func (f *Builder) Options() *Builder {
	return f.Method(http.MethodOptions)
}

// Connect sets the builder method to "CONNECT" and returns an http.Request.
func (f *Builder) Connect() *Builder {
	return f.Method(http.MethodConnect)
}

// Make creates a new http.Request from the information available in the Builder.
func (f *Builder) Make() (*http.Request, error) {

	// parse URL to validate
	url, err := url.Parse(f.url)
	if err != nil {
		return nil, err
	}

	// augment URL with additional query parameters
	url, err = addQueryParameters(url, f.parameters)
	if err != nil {
		return nil, err
	}

	// replace variables
	u := bindVariables(url, f.variables)

	request, err := http.NewRequest(f.method, u, f.body)
	if err != nil {
		return nil, err
	}

	request.Header = f.headers

	return request, nil
}

// String prints the current request builder internal state as a string.
func (f Builder) String() string {

	data := struct {
		Method     string      `json:"method,omitempty"`
		URL        string      `json:"url,omitempty"`
		Headers    http.Header `json:"headers,omitempty"`
		Parameters url.Values  `json:"parameters,omitempty"`
		Request    string      `json:"request,omitempty"`
		Body       string      `json:"body,omitempty"`
	}{
		Method:     f.method,
		URL:        f.url,
		Headers:    f.headers,
		Parameters: f.parameters,
	}

	if req, err := f.Make(); err == nil {
		data.Request = req.URL.String()
	}

	if f.body != nil {
		data.Body = fmt.Sprintf("%q (%T)", f.body, f.body)
	} else {
		data.Body = "nil"
	}

	b, _ := json.MarshalIndent(data, "", "  ")
	b = bytes.Replace(b, []byte("\\u003c"), []byte("<"), -1)
	b = bytes.Replace(b, []byte("\\u003e"), []byte(">"), -1)
	b = bytes.Replace(b, []byte("\\u0026"), []byte("&"), -1)

	return string(b)
}

func getValuesFrom(tag string, source interface{}) map[string][]string {
	var m map[string][]string
	switch reflect.ValueOf(source).Kind() {
	case reflect.Struct:
		m = getValuesFromStruct(tag, source)
	case reflect.Map:
		var ok bool
		if m, ok = source.(map[string][]string); !ok {
			panic("only structs and maps can be passed as sources")
		}
	case reflect.Ptr:
		if reflect.ValueOf(source).Elem().Kind() == reflect.Struct {
			source = reflect.ValueOf(source).Elem().Interface()
			m = getValuesFromStruct(tag, source)
		} else if reflect.ValueOf(source).Elem().Kind() == reflect.Map {
			source = reflect.ValueOf(source).Elem().Interface()
			var ok bool
			if m, ok = source.(map[string][]string); !ok {
				panic("only structs and maps can be passed as sources")
			}
		} else {
			panic("only structs and maps can be passed as sources")
		}
	default:
		panic("only structs and maps can be passed as sources")
	}
	return m
}

func getValuesFromStruct(tag string, source interface{}) map[string][]string {
	result := map[string][]string{}
	for key, values := range scan(tag, source) {
		// log.Debugf("tag is %q", key)
		for _, value := range values {
			s := ""
			if reflect.ValueOf(value).Kind() == reflect.Ptr && !reflect.ValueOf(value).IsNil() {
				s = fmt.Sprintf("%v", reflect.ValueOf(value).Elem().Interface())
			} else {
				s = fmt.Sprintf("%v", value)
			}
			if _, ok := result[key]; !ok {
				result[key] = []string{}
			}
			result[key] = append(result[key], s)
		}
	}
	return result
}

func addQueryParameters(requestURL *url.URL, parameters url.Values) (*url.URL, error) {
	qp, err := url.ParseQuery(requestURL.RawQuery)
	if err != nil {
		return nil, err
	}
	// encodes query structs into a url.Values map and merges maps
	for key, values := range parameters {
		for _, value := range values {
			qp.Add(key, value)
		}
	}
	// url.Values formats to a sorted "url encoded" string, e.g. "key=val&foo=bar"
	requestURL.RawQuery = qp.Encode()
	return requestURL, nil
}

func bindVariables(u *url.URL, variables map[string]string) string {
	re := regexp.MustCompile("\\{([_a-zA-Z]\\w*)\\}")
	s, err := url.PathUnescape(u.String())
	if err != nil {
		log.Errorf("error parsing URL: %v", err)
		return ""
	}

	log.Debugf("URL to bind: %q", s)
	matches := re.FindAllStringIndex(s, -1)
	if len(matches) == 0 {
		log.Debugf("no variables to bind, returning %q", u.String())
		return u.String()
	}
	var buffer bytes.Buffer
	pivot := 0
	for no, match := range matches {
		log.Debugf("match %d: %v (pivot: %d)", no, match, pivot)
		log.Debugf("... grabbing substring: %q", s[pivot:match[0]])
		buffer.WriteString(s[pivot:match[0]])
		key := s[match[0]+1 : match[1]-1]
		log.Debugf("... binding %q", key)
		if value, ok := variables[key]; ok {
			log.Debugf("... with value %q", value)
			buffer.WriteString(value)
		} else {
			buffer.WriteString(s[match[0]:match[1]])
		}
		log.Debugf("... buffer now: %q", buffer.String())
		pivot = match[1]
	}
	log.Debugf("... appending final token: %q", s[pivot+1:])
	buffer.WriteString(s[pivot:])
	s = buffer.String()
	log.Debugf("URL bound to variables, returning %q", s)
	return s
}

// scan is the actual workhorse method: it scans the source struct for tagged
// fields and extracts their values; its behaviour is the following:
// - untagged embedded structs, child structs and pointers to structs are scanned
//   recursively
// - tagged embedded structs, child structs and pointers to structs are converted
//   to string, provided they implement the Stringer interface, otherwise they
//   are ignored.
// - all other tagged values are extracted.
func scan(key string, source interface{}) map[string][]interface{} {
	result := map[string][]interface{}{}
	for _, field := range structs.Fields(source) {
		log.Debugf("analysing field %q for tag `%s`...", field.Name(), key)
		tag := NewTag(field.Tag(key))
		if tag.IsMissing() {
			// untagged field
			log.Debugf("... tag is missing")
			if field.Kind() == reflect.Struct {
				// recurse
				log.Debugf("... field is a struct, recursing...")
				for k, v := range scan(key, field.Value()) {
					if values, ok := result[k]; ok {
						result[k] = append(values, v...)
					} else {
						result[k] = v
					}
				}
			} else if field.Kind() == reflect.Ptr && reflect.ValueOf(field.Value()).Elem().Kind() == reflect.Struct {
				log.Debugf("... field is a struct pointer, recursing...")
				for k, v := range scan(key, reflect.ValueOf(field.Value()).Elem().Interface()) {
					if values, ok := result[k]; ok {
						result[k] = append(values, v...)
					} else {
						result[k] = v
					}
				}
			} else {
				// ignore
				log.Debugf("... untagged field or type %T, skipping...", field.Value())
				continue
			}
		} else if tag.IsIgnore() {
			// ignore
			log.Debugf("... field is tagged with \"-\" (type: %T), skipping...", field.Value())
			continue
		} else {
			// tagged field
			k := tag.Name()
			log.Debugf("... field is tagged with %q (type: %T)", k, field.Value())
			var value interface{}
			if field.Kind() == reflect.Struct {
				log.Debugf("... field is a struct, adding as is under %q...", k)
				value = field.Value()
			} else if field.Kind() == reflect.Ptr && reflect.ValueOf(field.Value()).Elem().Kind() == reflect.Struct {
				log.Debugf("... field is a struct pointer, adding after dereferencing under %q...", k)
				value = reflect.ValueOf(field.Value()).Elem().Interface()
			} else if isNilReferenceType(field.Value()) && tag.IsOmitEmpty() {
				// ignore nil omitempty fields
				log.Debugf("... field is nil reference and has \"omitempty\" (type: %T), skipping...", field.Value())
				continue
			} else if field.IsZero() && tag.IsOmitEmpty() {
				// ignore zero values for omitempty fields
				log.Debugf("... field is zero value and has \"omitempty\" (type: %T), skipping...", field.Value())
				continue
			} else if isZeroReferenceType(field.Value()) {
				log.Debugf("... field is pointer to zero value and has \"omitempty\" (type: %T), skipping...", field.Value())
				continue
			} else {
				log.Debugf("... field is a final value, adding as is under %q...", k)
				value = field.Value()
			}
			if values, ok := result[k]; ok {
				result[k] = append(values, value)
			} else {
				result[k] = []interface{}{value}
			}
		}
	}
	return result
}

func isNilReferenceType(value interface{}) bool {
	if value == nil {
		return true
	}
	switch reflect.ValueOf(value).Kind() {
	case reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Interface, reflect.Slice:
		return reflect.ValueOf(value).IsNil()
	}
	return false
}

func isZeroReferenceType(value interface{}) bool {
	if reflect.ValueOf(value).Kind() == reflect.Ptr {
		current := reflect.ValueOf(value).Elem().Interface()
		zero := reflect.Zero(reflect.ValueOf(current).Type()).Interface()
		return reflect.DeepEqual(current, zero)
	}
	return false
}
